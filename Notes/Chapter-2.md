# Chapter 2: Programming

Hacker is a term for both those who write code and those who exploit it. Since an understanding of programming helps hackers do their job, they tend to be relatively skilled when it comes to programming. Hackers on both sides of programming appreciate both the beauty and elegant code and the ingenuity of clever hacks.

In the modern day, programmers want their code to be functional rather than perfectly optimized. If they know that their program works in for all the cases that they want to, in a acceptable runtime then they wont be willing to spend 5 hours trying to make their program a little more efficient. This is becoming more and more true for the exponential growth that is occurring with computer memory and power.

An Assembler is one form of machine-language translator - it is a program that translates assembly language into machine-readable code. Assembly language is less cryptic that machine language but still not intuitive to write. Just as machine language for sparc processors, x86 assembly language is different from sparc's assembly language. A program written sing assembly language for one processor's architecture will not work on another processor's architecture.

Another way to mitigate the issue of having to write in shitty assembly code is to use a compiler. A compiler converts a high-level language into machine language. C, C++ and Fortran are all examples of high level languages.

Machine code --Assembler--> assembly code --Compiler--> high level language (C)

### for b = a++ * 6
b = a * 6
a = a + 1

### for b = ++a * 6
a = a + 1
b = a * 6

Comparison Operators:
  - Less than <
  - Greater than >
  - Less than or equal to <=
  - Greater than or equal to >=
  - Equal to ==
  - Not equal to !=


Sometimes there will be a set of instructions the programmer knows he will need several times. These instructions can be grouped into a smaller subprogram called a function. In other languages, functions are known as subroutines or procedures.You can pass variables as arguments to a function in order to modify the way the function operates.

# Our first program

```
#include <stdio.h>

int main(){
  int i;
  for(i = 0; i < 10; i++){
    printf("Hello world");
  }
  return 0;
}
```

Most header files are located in /usr/include/ directory. The stdio.h header file defines several constanst and function prototypes for corresponding functions in the standard IO library. The purpose of header files is to offer prototypes for the functions that are being called.

## Assembly and Compilers

The GNU compiler Collection is a free C compiler that translates C into machine language that a processor can understand. While a software developer might only care about the high level code that they write, hackers on the other hand know that it is the compiled program that is run not the actual high level code. With a understanding of how the CPU operates, a hacker can manipulate the programs that run on it (buffer overflows and such).

Hexadecimal is known as a base16 numbering system. After 0-9 it goes from A-F. Hexadecimal is helpful because we can store more information with it and we can easily convert from binary to hex and hex to binary.

When you use the objdump program you can see the actual assembly instructions that are used, the hex numbers that you see on the far left of that output are the memory address of the instruction that you are looking at.

Memory can be though of as a row of bytes, each with its own memory address. Each byte of memory can be accessed by its address, and in this case the CPU accesses this part of memory to retrieve the machine language instructions that make up the compiled program. Older Intel x86 processors use a 32-bit addressing scheme, while newer ones use a 64-bit one. The 32-bit processors have 2^32 possible addresses while the 64-bit ones have 2^64 possible addresses. With that said, 64-bit processors can run in 32-bit compatibility mode.

The hexademical bytes in the middle of the listing above are the machine language instructions for the x86 processor. The instructions in the far right of a objdump output is the assembly instruction which are the actual instructions that the processor will run. Assembly language instructions have a direct 1-1 relationship with their byte representation.

There are 2 main syntaxes that are used when it comes to assembly language, AT&T and Intel. One way to recognize AT&T syntax is by the addition of the $ and the 5 behind registers and literals.

If you wish to show the output of assembly code in intel syntax pass `-M intel` to the objdump command.

## The x86 Processor

GNU development tools comes with GDB. To view the states of the registers during runtime you can type `info registers` into GDB and it will show you. The GPRs for x86 are as follows: `EAX`, `ECX`, `EDX`, and `EBX`. Respectively these registers are called the Accumulator, Counter, Data, and Base registers. They have many purposes but they mainly serve as temporary variables for programs to use. The nest four registers: `ESP`, `EBP`, `ESI`, and `EDI` are also GPRs but they are sometimes know as pointers and indexes.  Respectively these stand for Stack Pointer, Base Pointer, Source Index, and Destination Index. The first two registers are called pointers because they store 32-bit addresses, which essentially point to that location in memory. The last two registers `ESI` and `EDI` are commonly used to point to the source and destination when data needs to be read from or written to.

The `EIP` register is the Instruction Pointer register, which points to the current instruction the processor is reading.

The remaining `EFLAGS` register consists of several bit flags that are used for comparisons and memory segmentations. The actually memory split into several different segments.

## GDB

The `-g` flag in GCC will include addition debugging information, which will give GDB access to source code.

To examine information in GDB you use the `x` command. This command takes 2 arguments, the location in memory to examine and how to display that memory. The display format is as follows
  o : Display in octal
  x : Display in Hexadecimal
  u : Display in unsigned, standard base-10 decimal
  t : Display in binary
  s : Display in string

x86 processors store values in little endian byte order, which means the least significant byte is stored first. For example, if four bytes are to interpreted as a single value the bytes must be used in reverse order.

## Strings

Since we know that strings are just character arrays, we could just declare all of our strings as character arrays. The issue with this is that it sucks... So instead we are allowed to declare strings. The strings library is used to manipulate strings but it comes with a few security flaws.

## Stack

It is important to point out that EIP is able to travel from the main code to the strcpy() code and back again. Each time a function is called, a record is kept on a data structure called the stack. The stack lets EIP return through long chains of function calls. In GDB, the `bt` command can be used to backtrace the stack.

## Signed, Unsigned, Long and Short
