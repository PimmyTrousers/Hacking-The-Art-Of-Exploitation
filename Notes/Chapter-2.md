# Chapter 2: Programming

Hacker is a term for both those who write code and those who exploit it. Since an understanding of programming helps hackers do their job, they tend to be relatively skilled when it comes to programming. Hackers on both sides of programming appreciate both the beauty and elegant code and the ingenuity of clever hacks.

In the modern day, programmers want their code to be functional rather than perfectly optimized. If they know that their program works in for all the cases that they want to, in a acceptable runtime then they wont be willing to spend 5 hours trying to make their program a little more efficient. This is becoming more and more true for the exponential growth that is occurring with computer memory and power.

An Assembler is one form of machine-language translator - it is a program that translates assembly language into machine-readable code. Assembly language is less cryptic that machine language but still not intuitive to write. Just as machine language for sparc processors, x86 assembly language is different from sparc's assembly language. A program written sing assembly language for one processor's architecture will not work on another processor's architecture.

Another way to mitigate the issue of having to write in shitty assembly code is to use a compiler. A compiler converts a high-level language into machine language. C, C++ and Fortran are all examples of high level languages.

Machine code --Assembler--> assembly code --Compiler--> high level language (C)

### for b = a++ * 6
b = a * 6
a = a + 1

### for b = ++a * 6
a = a + 1
b = a * 6

Comparison Operators:
  - Less than <
  - Greater than >
  - Less than or equal to <=
  - Greater than or equal to >=
  - Equal to ==
  - Not equal to !=


Sometimes there will be a set of instructions the programmer knows he will need several times. These instructions can be grouped into a smaller subprogram called a function. In other languages, functions are known as subroutines or procedures.You can pass variables as arguments to a function in order to modify the way the function operates.

# Our first program

```
#include <stdio.h>

int main(){
  int i;
  for(i = 0; i < 10; i++){
    printf("Hello world");
  }
  return 0;
}
```

Most header files are located in /usr/include/ directory. The stdio.h header file defines several constanst and function prototypes for corresponding functions in the standard IO library. The purpose of header files is to offer prototypes for the functions that are being called.

## Assembly and Compilers

The GNU compiler Collection is a free C compiler that translates C into machine language that a processor can understand. While a software developer might only care about the high level code that they write, hackers on the other hand know that it is the compiled program that is run not the actual high level code. With a understanding of how the CPU operates, a hacker can manipulate the programs that run on it (buffer overflows and such).

Hexadecimal is known as a base16 numbering system. After 0-9 it goes from A-F. Hexadecimal is helpful because we can store more information with it and we can easily convert from binary to hex and hex to binary.

When you use the objdump program you can see the actual assembly instructions that are used, the hex numbers that you see on the far left of that output are the memory address of the instruction that you are looking at.

Memory can be though of as a row of bytes, each with its own memory address. Each byte of memory can be accessed by its address, and in this case the CPU accesses this part of memory to retrieve the machine language instructions that make up the compiled program. Older Intel x86 processors use a 32-bit addressing scheme, while newer ones use a 64-bit one. The 32-bit processors have 2^32 possible addresses while the 64-bit ones have 2^64 possible addresses. With that said, 64-bit processors can run in 32-bit compatibility mode.

The hexademical bytes in the middle of the listing above are the machine language instructions for the x86 processor. The instructions in the far right of a objdump output is the assembly instruction which are the actual instructions that the processor will run. Assembly language instructions have a direct 1-1 relationship with their byte representation.

There are 2 main syntaxes that are used when it comes to assembly language, AT&T and Intel. One way to recognize AT&T syntax is by the addition of the $ and the 5 behind registers and literals.

If you wish to show the output of assembly code in intel syntax pass `-M intel` to the objdump command.

## The x86 Processor

GNU development tools comes with GDB. To view the states of the registers during runtime you can type `info registers` into GDB and it will show you. The GPRs for x86 are as follows: `EAX`, `ECX`, `EDX`, and `EBX`. Respectively these registers are called the Accumulator, Counter, Data, and Base registers. They have many purposes but they mainly serve as temporary variables for programs to use. The nest four registers: `ESP`, `EBP`, `ESI`, and `EDI` are also GPRs but they are sometimes know as pointers and indexes.  Respectively these stand for Stack Pointer, Base Pointer, Source Index, and Destination Index. The first two registers are called pointers because they store 32-bit addresses, which essentially point to that location in memory. The last two registers `ESI` and `EDI` are commonly used to point to the source and destination when data needs to be read from or written to.

The `EIP` register is the Instruction Pointer register, which points to the current instruction the processor is reading.

The remaining `EFLAGS` register consists of several bit flags that are used for comparisons and memory segmentations. The actually memory split into several different segments.

## GDB

The `-g` flag in GCC will include addition debugging information, which will give GDB access to source code.

To examine information in GDB you use the `x` command. This command takes 2 arguments, the location in memory to examine and how to display that memory. The display format is as follows
  o : Display in octal
  x : Display in Hexadecimal
  u : Display in unsigned, standard base-10 decimal
  t : Display in binary
  s : Display in string

x86 processors store values in little endian byte order, which means the least significant byte is stored first. For example, if four bytes are to interpreted as a single value the bytes must be used in reverse order.

## Strings

Since we know that strings are just character arrays, we could just declare all of our strings as character arrays. The issue with this is that it sucks... So instead we are allowed to declare strings. The strings library is used to manipulate strings but it comes with a few security flaws.

## Stack

It is important to point out that EIP is able to travel from the main code to the strcpy() code and back again. Each time a function is called, a record is kept on a data structure called the stack. The stack lets EIP return through long chains of function calls. In GDB, the `bt` command can be used to backtrace the stack.

## Signed, Unsigned, Long and Short

By default numerical values in C are signed. A 32-bit integer unsigned integer can contain values from 0 to 4,294,967,295. A 32-bit signed integer can contain all values from -2,147,483,648 to 2,147,283,647. The main difference between how these are stored in memory is that one bit is reserved for deciding whether the number is positive or negative. Positively signed vales look the same as unsigned values, but negative numbers are stored differently using a method called two's compliment. Two's compliment represents negative numbers in a form suited for binary adders- when a negative value in two's compliment is added to a positive number of the same magnitude, the result will be 0. This is done by:
  1. writing the positive number in binary
  2. then inverting all the bits
  3. add 1
This might sound strange but it works and allows negative numbers to be added in combination with positive numbers using binary adders.

## Pointers

The EIP register is a pointer that points to the current instruction during a programs execution by containing its memory address. The idea of pointers is used in C, also. since the physical memory cannot actually be moved, the information in it must be copied. IT can be very computationally expensive to copy large chunks of memory to be used by different functions or in different places. Since memory on the x86 architecture uses 32-bit addressing, pointers are also 32 bit sin size (4 bytes). Pointers are defined bt prepending an asterisk to the varaible name.

## Format Strings

The `printf()`function can be used to print more than just fixed strings. This function can also use format strings to print variables in many different formats. a foramt string is just a cahracter string with special escape sequneces that tell the function to insert variables printed in a specific format in place of the escape sequence. Each format parameter has a percent sign on it (%) and uses a single-cahracter shorthand very similar to formatting characters used by GDB commands.

| %d | Decimal         |
|----|-----------------|
| %u | Usigned Decimal |
| %x | Hexadecimal     |

All of the preceding format parameters receive their data as values, not pointers to values but strings and the number of bytes written so far expect pointers.

## Type casting

Typecasting is simply a way to temporarily change a variables type despite how it was originally created. As stated earlier dividing integer 13 by 5 will round down to the oncorrect answer of 2, even if this value is being stores into a floating point varaible. However, if these integer variables are typecasr into floats, they will be treated as such. This allows for the correct calculation of 2.6

Typecasting really shines with pointer variables. Even though a pointer is just a memory address, the C compiler still demands a data type for every pointer. One reason for this is to try to limit programming errors. An integer pointer should only point to integer data, while a character pointer should only point to a character data. Another reason is for pointer arithmetic. An integer is 4 bytes long while a character only takes ub one byte.

## Command Line Arguments

Instead of using scanf() to input data ito our program we can use command line arguements as in the following:

```
int main(int arg_count, string *argv[]){
  int i;
  printf("There were %d arguments privided:\n", arg_count);
  for(i = 0; i < arg_count; i++){
    printf("argument #%d\t-\t%s\n", i, argv[i]);
  }
}
```
Here we can see that arg_count holds the amount of command line arguments that are passed (this includes the binary). We can iterate through arv to print out the various arguments passed. Sometimes a program will want to use command line argument as an integer as opposed to a string. Regardles of this, the argument is passed in as a string; however there are standard conversion functions. Unlike simply typecasting these functions can actually convery character arrays containig numbers into actual integers. The most common of these functions is `iota()` which is short for ascii to integer. This function accepts a pointer to a string as its arguments and returns the integer value it represents.

Looking at convert.c there is an if statemnet that makes sure that 3 arguments are used before these strings are accessed. If the program tries to access memory that doesnt exist or that the program doesnt have permission to read, the program will crash. In C its important to chekc for these types of conditions and handle them in program logic. If the error- checking if statement is commented out this memory violation will be explored.

When a program isnt given enough command line arguments it still tries to access elements of the arguemnt array even though they dont exist. Memory is split into segments and some memeory addresses arent within the boundaries of the memory segments the program is given access to. When the program attempts to access an address that is out of bounds, it will crash and die in whats called a segmentation fault.

## Variable Scoping

Another concept regarding memory in C is variable scoping or the contexts of variables in functions. Variables can also have a global scope, which means they will persist aaceoss all functions. Variavles are global if they are defined at the beginning of the code outside of any functions. In addition to globals varialbes can also be defined as static variabes by prepending the kwywowrd static to the variable definition. Similar to global variables, a static variable remanins intact between function calls; however static variabels are also akin to local variables since they remain local within a particular context. One differnet and unique feature pf static variables is that they are only initialized once. 
