# Chapter 3: Memory Segmentation

A compiled programs memory is divided into five segements:
  - text
  - data
  - bss
  - heap
  - stack
Each segment represents a special portion of memory that is set aside for a certain purpose.

## Text segment
The text segment is also sometimes called the code segment. This is where the assembled machine language instructions of the program are located. The execution of instructions in this segment in nonlinear, thanks to the aforementions high-level control structures and functions which compile into branch jump and call instructions in assembly language. As a program executes the EIP is set to the first instruction in the text segment (main). The processor then follows an execution loop that does the following:
  1. Reads the instruction that EIP is pointing to
  2. Adds the byte length of the instruction to EIP
  3. Executes the instruction that was read in step 1
  4. go back to step 1
Sometimes the instruction will be a jump or a call instruction, which changed the EIP to a different address of memory. The processor doesnt care about the change, because its expecting the execution to be nonlinear anyways. If EIP is changed in step 3, the processor will just go back to step 1 and read the instruction foun at the address of whatever EIP is changed to.

Write permission is disabled in the text segment, as it is not used to store variables, only code. This prevents people from actually modifying the program code; any attemt to write to this segent of memory will cause the program to alert the user that something bad happened, and the program will be killed. Another advantage of this sefment being read only is that it can be shared amonf different cpies of the program, allowing multiple executions of the program at the same time without any problems. It should also be noted that this memory segment has a fixed size, since nothing ever changes in it

## Data and bss
The data nad bss segments are used to store gloval and static program variables. The data segment is filled with the initialized global and static variabels, while the bss segment is filled with their uninitialized counterparts. Although these segmenets are writable, they also have a fixed size. Remember that global variables persist, despite the functional context. Both Global and static variabels are avle to persist becasue they are stored in their own meory segments.

## Heap segment
The heap segment is asegment of memory a programmer can directly control. Blocks of memory in this segment can be allocated and used for whatever the programmer might need. One notable point about the heap segment is that it isnt a fixed size so it can grow larger or smaller as neede.d All of the memory with in the heap is managed by allocator and deallocator algorithms, which respectively reserve a region of memory in the heap for use and remove reservations to allow that portion of memory to be reused for later reservations. The heap will grow and shrink depending on how much meory is reserved for use. This means a programmer using the hepa allocation functions can reserve and free memory on the fly. The growth of the heap moves downward toward higher memory addresses.

## Stack segment
The stack segment also has variables size and is used as a temprary scratch pad to store local function variables and context during function calls. This is what GDB's backtrace command looks at. When a progarm calls a function that function will have its own set of passed variabels, and the functions code will be at a different memory location in the text segment. Since the context and the EIP must change when a function is called the stack is used to remember all of the passed variables, the location the EIP should return to after the function is finished and all the local variables used by that function. All of this information is stored together on the stack in what is collectively known as a stack frame. The stack contains many stack frames. 
